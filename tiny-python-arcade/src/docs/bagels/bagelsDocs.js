export const bagelsDocs = [
  {
    title: "Problem Overview",
    content: `
Bagels is a classic deductive number-guessing game where the player attempts to guess a secret number generated by the system. The system provides feedback after each guess using three types of clues:

Fermi → Correct digit in the correct position
Pico → Correct digit in the wrong position
Bagels → No correct digits

The goal of the game is to deduce the hidden number using logical reasoning based on these clues.
This implementation is built as a server-driven game module using Python and FastAPI. The backend handles secret generation, guess validation, clue calculation, and state management.
Let:
S = Secret number (n-digit string)
G = Player guess (n-digit string)
n = Number of digits

Digits are unique (optional constraint depending on difficulty)
Input:
Player submits guess G.
Output:
System returns:

List of clues (Fermi, Pico, or Bagels)
Updated attempt count
Game status (win/continue/lose)
`
  },
  {
    title: "Secret Number Generation Algorithm",
    content: `Objective:
Generate an n-digit number where:

Digits are unique
First digit is not zero
Random distribution

Step-by-step logic:
Create a list of digits 0–9
Shuffle the list
Ensure first digit ≠ 0
Select first n digits
Join into string

Example Implementation:
import random
def generate_secret(n=3):
    digits = list("0123456789")
    random.shuffle(digits)

    if digits[0] == "0":
        for i in range(1, len(digits)):
            if digits[i] != "0":
                digits[0], digits[i] = digits[i], digits[0]
                break

    return "".join(digits[:n])
`
  },

{
    title: "Clue Generation Algorithm (Core Logic)",
    content: `This is the heart of the game.

We compare guess G to secret S.
Logic:
For each index i:
If G[i] == S[i] → Fermi
Else if G[i] in S → Pico
If no matches → Bagels

Step-by-step breakdown:
Let:
S = 427
G = 472

Comparison:
Position	Secret	Guess	Result
0	4	4	Fermi
1	2	7	Pico
2	7	2	Pico

Output:
["Fermi", "Pico", "Pico"]
Sorted alphabetically (optional standardization).

Implementation:
def evaluate_guess(secret, guess):
    clues = []
    for i in range(len(guess)):
        if guess[i] == secret[i]:
            clues.append("Fermi")
        elif guess[i] in secret:
            clues.append("Pico")
    if not clues:
        return ["Bagels"]
    return sorted(clues)
`
},
{
    title: "Algorithm Complexity Analysis",
    content: `Secret Generation:
Shuffle: O(10)
Selection: O(n)
Overall: O(n)

Guess Evaluation:
Loop through n digits
Membership check in secret (O(n))

Worst case: O(n²)
For n=3 or n=4 → negligible.
`
},
{
  title: "State Management in Backend",
    content: `Since this is API-based, the server must maintain:
Secret number
Attempt count
Difficulty level
Win/loss state

Possible Approaches:
Method	Description	Used?
Global dictionary	Store sessions by ID	Common
In-memory object	Single-player session	Likely
Database	Persistent storage	Not used

In this implementation, state is maintained in memory, meaning:

Restarting server resets games
Suitable for lightweight deployment`
},
{
  title: "API Design",
    content: `Two main endpoints:
Start Game
POST /bagels/start
Input:
{"level": "easy"}

Output:
{"message": "Game started",
  "max_attempts": 10}

Submit Guess
POST /bagels/guess

Input:
{"guess": "427"}

Output:
{"clues": ["Fermi", "Pico"],
  "attempts_left": 7,
  "status": "continue"}

#   Validation Layer

Before evaluating guess:
Length must match secret length
Must be numeric
Must contain unique digits (if rule enabled)

Example:

def validate_guess(guess, n):
    if len(guess) != n:
        return False
    if not guess.isdigit():
        return False
    if len(set(guess)) != len(guess):
        return False
    return True

`
},
{
  title: "Conceptual Layers",
  content: `
`
}

];